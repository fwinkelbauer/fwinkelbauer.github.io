<!doctype html><html lang=en><head><title>Conference Talk Ideas</title><meta charset=utf-8><meta name=author content="Florian Winkelbauer"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=canonical href=https://florianwinkelbauer.com/notes/conference-talk-ideas/><link rel=alternate type=application/rss+xml title=RSS href=https://florianwinkelbauer.com/index.xml><link rel=stylesheet href=https://florianwinkelbauer.com/main.css></head><body><header class=dark><h2><a href=https://florianwinkelbauer.com/>Florian Winkelbauer</a></h2><nav><a href=/about>About</a>
<a href=/notes>Notes</a>
<a href=/projects>Projects</a></nav></header><main><article><header><h1><a href=https://florianwinkelbauer.com/notes/conference-talk-ideas/>Conference Talk Ideas</a></h1></header><p>In the future I would like to give presentations at software conferences. Here
are few topic ideas:</p><h2 id=neat-tricks-when-building-net-pipelines>Neat Tricks When Building .NET Pipelines</h2><p>Command line tools such as git and dotnet are terrific assets for building and
publishing your applications. We will investigate how they can be used in
different situations:</p><ul><li>Using git commands such as <code>git rev-parse</code> or <code>git clean</code> to improve a build
pipeline</li><li>The versatility of <code>dotnet publish</code><ul><li>Single binary, ahead-of-time compilation or self-contained builds</li><li>Add commit ID information</li></ul></li><li>Utility dotnet sub-commands such as <code>dotnet format</code> or <code>dotnet list package --outdated</code></li><li>Derive version information from a <code>CHANGELOG.md</code> file, automate release
commits and tagging</li></ul><h2 id=having-a-hobby-project>Having a Hobby Project</h2><p>In the last few years I built <a href=https://github.com/fwinkelbauer/chunkyard/>Chunkyard</a>, a backup tool which
combines full and incremental backups while also including features such as
copying and validating backups. Chunkyard does not offer much that other open
source backups tool provide, but it gave me several opportunities to explore
topics such as:</p><ul><li>How &ldquo;modern&rdquo; backup applications work</li><li>Use .NET on Windows and Linux</li><li>Testing new language features</li><li>Limit myself to the standard library</li><li>Create a useful and fast testing suite</li><li>Tinker with build and publish automation</li></ul><h2 id=content-addressable-storage--content-defined-chunking>Content Addressable Storage + Content Defined Chunking</h2><p>Modern backup tools use techniques such as content addressable storage and
content defined chunking to create deduplicated and verifiable backups. We will
explore how these techniques work and how they could be applied to other areas
such as:</p><ul><li>Version control systems</li><li>Application downloader/updater</li><li>Artifact storage for build pipelines</li><li>Verifiable URLs</li></ul><h2 id=teaching-an-old-dog-monolith-new-tricks>Teaching an Old <del>Dog</del> Monolith New Tricks</h2><p>Its 2023 but some of us are still doing manual deployments to ship software.
Let&rsquo;s have a look at a concrete example of a distributed monolith and what we
can do to automate its deployment:</p><ul><li>Implement a &ldquo;deployment configuration&rdquo; using a templating language, reusable
configuration files and scripts</li><li>Generate a &ldquo;deployment configuration&rdquo; using different criteria</li><li>Use a package manager like <a href=https://chocolatey.org/>Chocolatey</a> (Windows)</li></ul></article></main><footer><p>Copyright 2023, Florian Winkelbauer. All rights reserved.</p></footer></body></html>