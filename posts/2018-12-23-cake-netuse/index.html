<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Copy Files to a Remote Location Using Cake</title>
<meta name="generator" content="Org Mode" />
<meta name="author" content="Florian Winkelbauer">
<link rel="stylesheet" href="/site.css" type="text/css">
</head>
<body>
<div id="preamble" class="status">
<nav>
<a href="/">Home</a>
<a href="/notes">Notes</a>
<a href="/posts">Posts</a>
<a href="/projects">Projects</a>
</nav>
</div>
<div id="content" class="content">
<header>
<h1 class="title">Copy Files to a Remote Location Using Cake</h1>
</header><p>
I have recently had the need to copy files from one Windows machine to another
in a Cake build task. A rather easy way to achieve this is to use the `net`
command line tool, which I have wrapped into a few lines of C#. Here's how to
use the code:
</p>

<div class="org-src-container">
<pre class="src src-csharp">readonly var target = Argument("target", "Default");

Task("Default")
    .Does(() =&gt;
{
    using (var session = NetUse("\\\\some-machine", "domain\\user", "password"))
    {
        // Use Cake's existing IO library
        CopyFileToDirectory("myfile.txt", session.ToRemote("C:/"));
    }
});

RunTarget(target);
</pre>
</div>

<p>
The two most important bits include:
</p>

<ul class="org-ul">
<li>Opening a session using the <code>NetUse</code> method</li>
<li>Using the <code>session.ToRemote</code> method to turn a "normal" path into a remote
path (e.g. <code>C:\</code> -&gt; <code>\\some-machine\c$\</code>)</li>
</ul>

<p>
Here's the actual <code>NetUse</code> implementation:
</p>

<div class="org-src-container">
<pre class="src src-csharp">public NetUseSession NetUse(string machine, string username, string password)
{
    Information($"Connecting to '{machine}'");
    var exitCode = StartProcess("net", new ProcessSettings
    {
        Arguments = new ProcessArgumentBuilder()
            .Append("use")
            .Append(machine)
            .AppendSecret(password)
            .Append($"/user:{username}")
    });

    if (exitCode != 0) {
        throw new Exception($"Could not connect to '{machine}'");
    }

    Func&lt;string, int&gt; closeFunc = (m) =&gt;
    {
        Information($"Deleting connection to '{m}'");
        return StartProcess("net", new ProcessSettings
        {
            Arguments = new ProcessArgumentBuilder()
                .Append("use")
                .Append(m)
                .Append("/delete"),
        });
    };

    return new NetUseSession(machine, closeFunc);
}

public sealed class NetUseSession : IDisposable
{
    private readonly string _machine;
    private readonly Func&lt;string, int&gt; _close;

    public NetUseSession(string machine, Func&lt;string, int&gt; close)
    {
        _machine = machine;
        _close = close;
    }

    public DirectoryPath ToRemote(DirectoryPath directory)
    {
        var remoteDirectory = directory.ToString().Replace(":", "$");
        return $"{_machine}/{remoteDirectory}";
    }

    public void Dispose()
    {
        var exitCode = _close(_machine);

        if (exitCode != 0) {
            throw new Exception($"Could not delete connection to '{_machine}'");
        }
    }
}
</pre>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Published: 2018-12-23</p>
<footer>
<p>Copyright 2024, Florian Winkelbauer. All rights reserved.</p>
</footer>
</div>
</body>
</html>
