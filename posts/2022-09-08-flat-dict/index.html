<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>A Flat Dictionary Serializer in C#</title>
<meta name="generator" content="Org Mode" />
<meta name="author" content="Florian Winkelbauer">
<link rel="stylesheet" href="/site.css" type="text/css">
</head>
<body>
<div id="preamble" class="status">
<nav>
<a href="/">Home</a>
<a href="/notes">Notes</a>
<a href="/posts">Posts</a>
<a href="/projects">Projects</a>
</nav>
</div>
<div id="content" class="content">
<header>
<h1 class="title">A Flat Dictionary Serializer in C#</h1>
</header><p>
Recently I have been working with rather large YAML config files and I was
wondering if there was an easy way to diff them. <a href="https://github.com/TomNomNom/gron">Gron</a> is a pretty cool command
line tool which claims to make JSON greppable by transforming it into discrete
assignments. It turns out that this format is also a great input for diff tools
if you sort the assignments. I stumbled over <a href="https://josef.codes/transform-csharp-objects-to-a-flat-string-dictionary/">this blog post</a> in which the author
presents a similar transformation for C# objects. After some minor tweaks I came
up with my own implementation based on the first dynamic solution of said post:
</p>

<div class="org-src-container">
<pre class="src src-csharp">public static class FlatDictionarySerializer
{
    public static Dictionary&lt;string, string?&gt; Serialize(
        object? obj,
        string name = "")
    {
        var dictionary = new Dictionary&lt;string, string?&gt;();

        Flatten(dictionary, obj, name);

        return dictionary;
    }

    private static void Flatten(
        IDictionary&lt;string, string?&gt; dictionary,
        object? obj,
        string prefix)
    {
        if (obj == null)
        {
            dictionary.Add(prefix, null);

            return;
        }

        var objType = obj.GetType();

        if (objType.IsValueType || objType == typeof(string))
        {
            dictionary.Add(prefix, obj.ToString());
        }
        else if (obj is IEnumerable subObjects)
        {
            var counter = 0;

            foreach (var subObj in subObjects)
            {
                Flatten(dictionary, subObj, $"{prefix}[{counter++}]");
            }
        }
        else
        {
            var properties = objType.GetProperties().Where(x =&gt; x.CanRead);

            foreach (var property in properties)
            {
                Flatten(
                    dictionary,
                    property.GetValue(obj),
                    string.IsNullOrEmpty(prefix)
                        ? property.Name
                        : $"{prefix}.{property.Name}");
            }
        }
    }
}
</pre>
</div>

<p>
<b>Note:</b> Adding support for dictionaries only makes sense for a type signature of
<code>IDictionary&lt;string, object&gt;</code> since other key types such as random objects might
be hard to "stringify".
</p>

<p>
<b>Update 2022-09-11:</b> Another alternative is to use <a href="https://github.com/Wilfred/difftastic">difftastic</a>,
which also supports JSON and YAML files.
</p>
</div>
<div id="postamble" class="status">
<p class="date">Published: 2022-09-08</p>
<footer>
<p>Copyright 2025, Florian Winkelbauer. All rights reserved.</p>
</footer>
</div>
</body>
</html>
