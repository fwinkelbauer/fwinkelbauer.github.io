<!doctype html><html lang=en><head><title>Building a Barebones Task Runner</title><meta charset=utf-8><meta name=generator content="Hugo 0.100.1"><meta name=author content="Florian Winkelbauer"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=canonical href=https://florianwinkelbauer.com/posts/2019-12-24-powershell-taskrunner/><link rel=alternate type=application/rss+xml title=RSS href=https://florianwinkelbauer.com/index.xml><link rel=stylesheet href=https://florianwinkelbauer.com/main.css></head><body><header class=dark><h2><a href=https://florianwinkelbauer.com/>Florian Winkelbauer</a></h2><nav><a href=/about>About</a>
<a href=/notes>Notes</a>
<a href=/projects>Projects</a></nav></header><main><article><header><h1><a href=https://florianwinkelbauer.com/posts/2019-12-24-powershell-taskrunner/>Building a Barebones Task Runner</a></h1><time datetime=2019-12-24T00:00:00Z>December 24, 2019</time></header><p>Several people have already build a bazillion frameworks or libraries in which
you can define and run a set of tasks and their dependencies. PowerShell has
<a href=https://github.com/psake/psake>psake</a> and <a href=https://github.com/nightroman/Invoke-Build>Invoke-Build</a>. I was curious how these systems
work, so I wrote a small PowerShell library which only showcases a trivial
implementation.</p><p>Tasks and their dependencies form a directed acyclic graph (DAG). We only want
to run each task once, even if several tasks depend on it. A naive task runner
might operate like this:</p><ul><li>Identify all leaves (tasks at the end of the graph which have not been run)</li><li>Run these tasks one after the other</li><li>Mark these tasks as finished (which &ldquo;removes&rdquo; them from the graph)</li></ul><p>Here&rsquo;s a short <code>build.ps1</code> script which defines a few tasks:</p><pre><code class=language-powershell>param(
    [ValidateSet('Help', 'First', 'Second', 'Third')]
    [string]$Target = 'Third'
)

$ErrorActionPreference = 'Stop'

Import-Module '.\task.psm1'

Register-Task -Name 'Help' {
    Write-TaskOverview
}

$firstTask = Register-Task -Name 'First' -PassThru {
    Write-Output 'First!'
}

$secondTask = Register-Task -Name 'Second' -DependsOn $firstTask -PassThru {
    Write-Output 'Second!'
}

Register-Task -Name 'Third' -DependsOn $firstTask, $secondTask {
    Write-Output 'Third!'
}

Get-Task $Target | Invoke-Task
Write-TaskReport
</code></pre><p>We can run any task by passing its name:</p><ul><li><code>build.ps1 -Target Help</code></li><li><code>build.ps1 -Target Second</code></li><li>&mldr;</li></ul><p>The <code>task.psm1</code> file looks like this:</p><pre><code class=language-powershell>$registeredTasks = @{}
$taskResults = [ordered]@{}

class TaskObject {
    [string]$Name
    [TaskObject[]]$DependsOn
    [scriptblock]$Do
}

class TaskResult {
    [string]$Name
    [TimeSpan]$Duration
}

function Register-Task {
    param(
        [Parameter(Mandatory = $true)]
        [string]$Name,
        [scriptblock]$Do = { },
        [TaskObject[]]$DependsOn = @(),
        [switch]$PassThru
    )

    $task = [TaskObject]::new()
    $task.Name = $Name
    $task.DependsOn = $DependsOn
    $task.Do = $Do

    $registeredTasks[$Name] = $task

    if ($PassThru) {
        $task
    }
}

function Get-Task {
    param(
        [Parameter(Mandatory = $true)]
        [string]$Name
    )

    $registeredTasks[$Name]
}

function Invoke-SingleTask {
    param(
        [Parameter(Mandatory = $true)]
        [TaskObject]$Task
    )

    Write-Output ''
    Write-Output '================================================================================'
    Write-Output &quot;Task '$($Task.Name)'&quot;
    Write-Output '================================================================================'

    $start = Get-Date

    &amp; $Task.Do

    $end = Get-Date
    $taskResult = [TaskResult]::new()
    $taskResult.Name = $Task.Name
    $taskResult.Duration = $end - $start
    $taskResults[$runnableTask.Name] = $taskResult
}

function Invoke-Task {
    param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [TaskObject]$Task
    )

    $taskResults.Clear()

    Do {
        $runnableTasks = Get-TaskLeave -Task $Task

        foreach ($runnableTask in $runnableTasks) {
            Invoke-SingleTask -Task $runnableTask
        }
    } While($runnableTasks.Length -ne 0)
}

function Write-TaskReport {
    $totalDuration = [timespan]::Zero
    $results = New-Object System.Collections.Generic.List[TaskResult]

    foreach ($key in $taskResults.Keys) {
        $taskResult = $taskResults[$key]
        $totalDuration += $taskResult.Duration
        $results.Add($taskResult)
    }

    $totalResult = [TaskResult]::new()
    $totalResult.Name = 'Total'
    $totalResult.Duration = $totalDuration

    $results.Add($totalResult)
    $results | Format-Table
}

function Write-TaskOverview {
    $tasks = New-Object System.Collections.Generic.List[TaskObject]

    foreach ($key in $registeredTasks.Keys) {
        $tasks.Add($registeredTasks[$key])
    }

    $tasks | Format-Table -Property Name, DependsOn
}

function Get-TaskLeave {
    param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [TaskObject]$Task
    )

    $runnableTasks = New-Object System.Collections.Generic.List[TaskObject]
    $hasRunnableDependencies = $false

    foreach ($dependency in $Task.DependsOn) {
        foreach ($leave in (Get-TaskLeave -Task $dependency)) {
            if ((-not $taskResults.Contains($leave.Name)) -and (-not $runnableTasks.Contains($leave))) {
                $hasRunnableDependencies = $true
                $runnableTasks.Add($leave)
            }
        }
    }

    if ((-not $hasRunnableDependencies) -and (-not $taskResults.Contains($Task.Name)) -and (-not $runnableTasks.Contains($leave))) {
        $runnableTasks.Add($Task)
    }

    $runnableTasks
}
</code></pre></article></main><footer><p>Copyright 2022, Florian Winkelbauer. All rights reserved.</p></footer></body></html>