<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Florian Winkelbauer</title><link>https://florianwinkelbauer.com/posts/</link><description>Recent content in Posts on Florian Winkelbauer</description><generator>Hugo -- gohugo.io</generator><copyright>Copyright 2022, Florian Winkelbauer. All rights reserved.</copyright><lastBuildDate>Sun, 13 Mar 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://florianwinkelbauer.com/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Having A Hobby Project</title><link>https://florianwinkelbauer.com/posts/2022-03-13-hobby-project/</link><pubDate>Sun, 13 Mar 2022 00:00:00 +0000</pubDate><guid>https://florianwinkelbauer.com/posts/2022-03-13-hobby-project/</guid><description>It has been two years since I have started to work on my hobby project Chunkyard. Over these years I have used this project to test out different ideas and concepts, which is something that you cannot always do in a professional environment. This post highlights a few topics which I have explored.
Ambitions My initial plans were to create some sort of general purpose library (hah!) that I could use to implement different types of applications such as a version control system, a backup tool or some sort of application installer/updater.</description></item><item><title>My Emacs Journey 2021</title><link>https://florianwinkelbauer.com/posts/2021-11-28-emacs-journey/</link><pubDate>Sun, 28 Nov 2021 00:00:00 +0000</pubDate><guid>https://florianwinkelbauer.com/posts/2021-11-28-emacs-journey/</guid><description>Another year, another Emacs report!
Cutting-Back As some sort of experiment I have tried to reduce the amount of plugins and custom code as much as possible to see if I can live without them. This gives me an opportunity to find ways that work with either vanilla Emacs or with tools that are already installed through plugin dependencies.
One Transient To Rule Them All All of my custom keybindings are accessible using the &amp;lt;apps&amp;gt; or &amp;lt;menu&amp;gt; keys.</description></item><item><title>Building C# using C#</title><link>https://florianwinkelbauer.com/posts/2021-10-04-building-csharp/</link><pubDate>Mon, 04 Oct 2021 00:00:00 +0000</pubDate><guid>https://florianwinkelbauer.com/posts/2021-10-04-building-csharp/</guid><description>Having your own pet project gives you the great possibility to try things you would not want to explore in a serious project. One of my latest experiments made me rethink how I create build scripts (which I have mentioned before in a previous blog post): What if I would use C# as a &amp;ldquo;scripting language&amp;rdquo; in order to create a build script. Or even better: What if I could create a CLI tool which deals with all my build tasks?</description></item><item><title>Org-Mode Timer</title><link>https://florianwinkelbauer.com/posts/2021-08-24-org-timer/</link><pubDate>Tue, 24 Aug 2021 00:00:00 +0000</pubDate><guid>https://florianwinkelbauer.com/posts/2021-08-24-org-timer/</guid><description>Org-mode appears to be one of those friends you have known for a long time but for some reason you just keep stumbling upon new profound things you just didn&amp;rsquo;t know about them. I had this moment when I discovered timers. There are different ways to clock work or to start an increasing or decreasing timer which are described in the org-mode documentation here and here. These functions can be used to interact with a decreasing timer:</description></item><item><title>Psake Enhancements</title><link>https://florianwinkelbauer.com/posts/2021-07-09-psake-enhancements/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://florianwinkelbauer.com/posts/2021-07-09-psake-enhancements/</guid><description>Psake is make-like tool written in PowerShell. Instead of a makefile you write a psakefile.ps1 which consists of a set of tasks. Calling psake &amp;lt;task name&amp;gt; searches for a psakefile.ps1 in the current directory to then call the given task. Most of the time I store my psakefile.ps1 in the root of my git project, which means that I have to set the working directory of my terminal to this directory.</description></item><item><title>Using Git with GNOME Keyring</title><link>https://florianwinkelbauer.com/posts/2021-05-27-git-gnome-keyring/</link><pubDate>Thu, 27 May 2021 00:00:00 +0000</pubDate><guid>https://florianwinkelbauer.com/posts/2021-05-27-git-gnome-keyring/</guid><description>Since GitHub has deprecated password-based authentication when using the Git CLI I have been searching for a solution to store GitHub&amp;rsquo;s personal access tokens (HTTPS authentication) in a safe manner on Linux. My Xubuntu installation uses GNOME Keyring, which is unlocked when I log onto the system, so using this keyring seemed to be the most reasonable approach.
A default Git installation ships with several credential helpers, so we need to configure Git to use one of these helpers.</description></item><item><title>Minor Org-Mode Features</title><link>https://florianwinkelbauer.com/posts/2021-05-26-org-features/</link><pubDate>Wed, 26 May 2021 00:00:00 +0000</pubDate><guid>https://florianwinkelbauer.com/posts/2021-05-26-org-features/</guid><description>This post builds upon a previous post about org-mode links.
Custom Links The in-buffer setting
#+LINK: issue https://company.issue.tracker.com/ticket?id= [[issue:42][Major Bug]] can also be written in elisp like this:
(setq org-link-abbrev-alist '((&amp;quot;issue&amp;quot; . &amp;quot;https://company.issue.tracker.com/ticket?id=%s&amp;quot;))) Smart Browser Selection Clicking a URL inside of org-mode opens your default browser. This behavior can be customized using the variable browse-url-browser-function, which is handy if a website only loads in a specific browser. You can either write your own URL handler, or you can specify a regex based lookup list:</description></item><item><title>Storing Git Repositories using Chunkyard</title><link>https://florianwinkelbauer.com/posts/2021-04-04-storing-git-in-chunkyard/</link><pubDate>Sun, 04 Apr 2021 00:00:00 +0000</pubDate><guid>https://florianwinkelbauer.com/posts/2021-04-04-storing-git-in-chunkyard/</guid><description>Sometimes you don&amp;rsquo;t want to store a Git repository on a dedicated server. An easy trick is to use a network drive or a cloud drive (e.g. Dropbox, NextCloud or others) by using a bare repository:
cd ~/SynchronizedFolder mkdir my-git-project cd my-git-project git init --bare Which can than be used like this:
cd ~/Projects/my-git-project git add remote origin ~/SynchronizedFolder/my-git-project git push --set-upstream origin master I have recently experimented with storing such repositories using my backup tool Chunkyard.</description></item><item><title>My Emacs Journey 2020</title><link>https://florianwinkelbauer.com/posts/2020-12-11-emacs-journey/</link><pubDate>Fri, 11 Dec 2020 00:00:00 +0000</pubDate><guid>https://florianwinkelbauer.com/posts/2020-12-11-emacs-journey/</guid><description>I guess I am not alone when I&amp;rsquo;ll say that COVID-19 made this year go by in an instant. It&amp;rsquo;s time to write a small report on my Emacs usage.
Org-Mode &amp;amp; Magit Even if some fancy editor would make me consider to stop using Emacs, I&amp;rsquo;d still use it just for org-mode and magit. Both tools are mentioned over and over on the internet and I can understand why (even if it starts to become boring).</description></item><item><title>Chunkyard Explained</title><link>https://florianwinkelbauer.com/posts/2020-10-03-chunkyard-explained/</link><pubDate>Sat, 03 Oct 2020 00:00:00 +0000</pubDate><guid>https://florianwinkelbauer.com/posts/2020-10-03-chunkyard-explained/</guid><description>Since my last blog post about Chunkyard the project has reached v1.1.1. Chunkyard is now a single .NET project and does no longer rely on components written in other languages. I also took the time to write down what the project should and should not do in the README file.
I believe that the overall internal data structure is stable, so I&amp;rsquo;d like to take the time to document how a file is stored.</description></item><item><title>Shared Scripts on Windows and Linux</title><link>https://florianwinkelbauer.com/posts/2020-08-09-portable-scripts/</link><pubDate>Sun, 09 Aug 2020 00:00:00 +0000</pubDate><guid>https://florianwinkelbauer.com/posts/2020-08-09-portable-scripts/</guid><description>Sometimes you end up in a situation where you would like to use the same script on different operating systems (e.g. Linux and Windows). Now you have to choose between two possibilities:
Write the same script in different languages (e.g. Bash and PowerShell) Write your script in one language and ensure that you can use it on all systems (e.g. by using PowerShell Core) I&amp;rsquo;ve recently experimented with the second approach.</description></item><item><title>Pretty Org-Agenda</title><link>https://florianwinkelbauer.com/posts/2020-07-13-org-agenda-icons/</link><pubDate>Mon, 13 Jul 2020 00:00:00 +0000</pubDate><guid>https://florianwinkelbauer.com/posts/2020-07-13-org-agenda-icons/</guid><description>A few days ago this Reddit post about icons in the org-agenda view took me by surprise. In the past I have tried to find ways to use different colors depending on the context of a TODO item (without any success), but I never thought about using icons (or that org-mode even supports category based icons). I was even more impressed when a user called &amp;ldquo;asiledeneg&amp;rdquo; posted some elisp code to use the all-the-icons Emacs package.</description></item><item><title>Even Better Emacs Org-Mode Links</title><link>https://florianwinkelbauer.com/posts/2020-06-15-org-links/</link><pubDate>Mon, 15 Jun 2020 00:00:00 +0000</pubDate><guid>https://florianwinkelbauer.com/posts/2020-06-15-org-links/</guid><description>In a previous blog post I talked about how I am using org-mode links to create shortcuts for accessing my projects. The outlined solution was using link shortcuts with custom elisp code. While this is a valid solution, clicking such a link prompts you for a &amp;ldquo;would you like to run this code?&amp;rdquo; confirmation, which is annoying. There is a variable to avoid this popup, but using it is a questionable decision regarding security.</description></item><item><title>Org-Mode Calendar Notifications</title><link>https://florianwinkelbauer.com/posts/2020-05-02-org-notifications/</link><pubDate>Sat, 02 May 2020 00:00:00 +0000</pubDate><guid>https://florianwinkelbauer.com/posts/2020-05-02-org-notifications/</guid><description>I was wondering if I could create notifications for my calendar entries in org-mode on Windows and Linux and it turns out, that the setup isn&amp;rsquo;t that complex.
The appt module can display notifications for specific appointments, so we need to export org-mode entries as appointments:
(require 'appt) (appt-activate t) (defun fw/org-agenda-to-appt () &amp;quot;Rebuild all appt reminders using org.&amp;quot; (interactive) (setq appt-time-msg-list nil) (org-agenda-to-appt)) (fw/org-agenda-to-appt) (add-hook 'org-agenda-finalize-hook 'fw/org-agenda-to-appt) The above snippet will create appointments when Emacs boots up and every time when we open org-agenda.</description></item><item><title>Dotnet Build Tools</title><link>https://florianwinkelbauer.com/posts/2020-04-04-dotnet-build/</link><pubDate>Sat, 04 Apr 2020 00:00:00 +0000</pubDate><guid>https://florianwinkelbauer.com/posts/2020-04-04-dotnet-build/</guid><description>In the last five years, the dotnet build environment has grown so much. When I started as a C# developer a few years ago, all my builds were done by hand. Deploying an artifact meant to manually copy it onto the target machine. Since then I have improved my process step by step.
Abusing the Pre/Post Build Snippets A csproj file can contain pre- and post-build snippets. I have used this feature to create an automated deployment when switching the build configuration from &amp;ldquo;Debug&amp;rdquo; to &amp;ldquo;Release&amp;rdquo;.</description></item><item><title>Notes on Building Chunkyard</title><link>https://florianwinkelbauer.com/posts/2020-03-13-building-chunkyard/</link><pubDate>Fri, 13 Mar 2020 00:00:00 +0000</pubDate><guid>https://florianwinkelbauer.com/posts/2020-03-13-building-chunkyard/</guid><description>Based on my previous blog post I have started a new C# project called Chunkyard where I can play with concepts such as content addressable storage and content defined chunking. This project is highly experimental and my goal is to implement a backup application with a limited set of features. Chunkyard gathers files in a given directory and stores a de-duplicated and encrypted snapshot. In this post I&amp;rsquo;d like to highlight a few topics that came up while figuring out how to implement Chunkyard.</description></item><item><title>Dreaming of Git with Chunks</title><link>https://florianwinkelbauer.com/posts/2020-02-08-git-with-chunks/</link><pubDate>Sat, 08 Feb 2020 00:00:00 +0000</pubDate><guid>https://florianwinkelbauer.com/posts/2020-02-08-git-with-chunks/</guid><description>I see more and more people using content addressable storage together with content defined chunking (CDC) to pull off interesting applications. Here are a few examples:
League Of Legends&amp;rsquo; patch downloader Asuran rdedup borg restic I&amp;rsquo;d love to see a distributed version control system (DVCS) which is based on CDC (which support for encryption and compression). So far, I have only found the Attaca project, which seems to be unmaintained at the moment.</description></item><item><title>Building a Barebones Task Runner</title><link>https://florianwinkelbauer.com/posts/2019-12-24-powershell-taskrunner/</link><pubDate>Tue, 24 Dec 2019 00:00:00 +0000</pubDate><guid>https://florianwinkelbauer.com/posts/2019-12-24-powershell-taskrunner/</guid><description>Several people have already build a bazillion frameworks or libraries in which you can define and run a set of tasks and their dependencies. PowerShell has psake and Invoke-Build. I was curious how these systems work, so I wrote a small PowerShell library which only showcases a trivial implementation.
Tasks and their dependencies form a directed acyclic graph (DAG). We only want to run each task once, even if several tasks depend on it.</description></item><item><title>My Emacs Journey 2019</title><link>https://florianwinkelbauer.com/posts/2019-12-20-emacs-journey/</link><pubDate>Fri, 20 Dec 2019 00:00:00 +0000</pubDate><guid>https://florianwinkelbauer.com/posts/2019-12-20-emacs-journey/</guid><description>Let me start my saying that yes, I still use Emacs. What a surprise. In fact, Emacs is one of my most used tools besides other stables such as a browser. What has changed though, is how I am using some aspects of this little editor.
What Has Not Changed I still believe, that Emacs is not the &amp;ldquo;right&amp;rdquo; tool for everything. I&amp;rsquo;m still jumping into Notepad++ if I want to do a very quick edit on a Windows machine.</description></item><item><title>Dealing with Version Information</title><link>https://florianwinkelbauer.com/posts/2019-11-01-version-management/</link><pubDate>Fri, 01 Nov 2019 00:00:00 +0000</pubDate><guid>https://florianwinkelbauer.com/posts/2019-11-01-version-management/</guid><description>About two years ago I was using a tool called zero29 to update AssemblyInfo.cs files in my C# projects. The author Mark Seemann (who&amp;rsquo;s talks I can highly recommend) declined my request to add support for .nuspec files. His point was, that zero29 is a tool to manage AssemblyInfo.cs files and that&amp;rsquo;s all it should ever do. While I am a big proponent of the Unix philosophy, I wished that zero29 would act as a tool to manage version information across all kinds of files.</description></item><item><title>Creating a Standalone Offline Chocolatey Installer</title><link>https://florianwinkelbauer.com/posts/2019-09-27-standalone-chocolatey-installer/</link><pubDate>Fri, 27 Sep 2019 00:00:00 +0000</pubDate><guid>https://florianwinkelbauer.com/posts/2019-09-27-standalone-chocolatey-installer/</guid><description>The Chocolatey install documentation includes a section about why there isn&amp;rsquo;t an MSI to install Chocolatey. In case that you are still searching for an executable, this post outlines a way to create your own &amp;ldquo;setup&amp;rdquo; using a self extracting 7-zip archive. We&amp;rsquo;ll need the following directory structure:
config.txt: A 7-zip configuration file install.bat: A wrapper script to call install.ps1 install.ps1: This script will perform the actual installation inside the 7-zip archive build.</description></item><item><title>Valuing Ground Separation</title><link>https://florianwinkelbauer.com/posts/2019-09-10-valuing-ground-separation/</link><pubDate>Tue, 10 Sep 2019 00:00:00 +0000</pubDate><guid>https://florianwinkelbauer.com/posts/2019-09-10-valuing-ground-separation/</guid><description>I can&amp;rsquo;t remember where I first picked it up, but a saying claims, that one should not try to save on things that separate you from the ground. This might include footwear, tires, a bed or chairs. A close friend stopped buying cheap shoes because of that saying. Another one bought a stone pine bed. And here I am today, writing this while sitting on an Aeron office chair at home.</description></item><item><title>Storing Secrets in Git using PowerShell</title><link>https://florianwinkelbauer.com/posts/2019-08-23-powershell-git-secrets/</link><pubDate>Fri, 23 Aug 2019 00:00:00 +0000</pubDate><guid>https://florianwinkelbauer.com/posts/2019-08-23-powershell-git-secrets/</guid><description>Storing secrets (passwords, API keys and so on) in Git is a bad idea. We all know that. But somehow, we still end up doing it anyway. Some people have come up with decent solutions to this problem. They are using asymmetric encryption to store their secrets. Notable examples include git-crypt, git-secret, or blackbox. But all three tools have one thing in common: they are bash tools, which leaves the Windows folks out in the rain.</description></item><item><title>Exporting from Homebank and Importing into Ledger</title><link>https://florianwinkelbauer.com/posts/2019-08-15-ledger/</link><pubDate>Thu, 15 Aug 2019 00:00:00 +0000</pubDate><guid>https://florianwinkelbauer.com/posts/2019-08-15-ledger/</guid><description>I am using Homebank to keep track of my financial situation. Recently, I thought about switching to Ledger (which belongs to a family of plaintext accounting tools). Homebank does not offer any decent export features, so I had to come up with my own strategies to transfer my data into the Ledger format.
The following Python script transforms a Homebank file into CSV:
#!/usr/bin/env python3 import argparse import datetime from decimal import Decimal import xml.</description></item><item><title>Motivating Programmers</title><link>https://florianwinkelbauer.com/posts/2019-08-12-motivation/</link><pubDate>Mon, 12 Aug 2019 00:00:00 +0000</pubDate><guid>https://florianwinkelbauer.com/posts/2019-08-12-motivation/</guid><description>Software Engineering Radio has recently published a terrific podcast about Motivating Programmers. Topics include:
That the relationship between a manager and a programmer is a strong indicator for employee turnover Why 1:1s should include the expectations and goals of both parties That job promotions could be implemented using small experiments and trial Why a manager should not be afraid to ask &amp;ldquo;are you searching for a new job?&amp;rdquo;</description></item><item><title>Literate Dotfiles</title><link>https://florianwinkelbauer.com/posts/2019-08-10-literate-dotfiles/</link><pubDate>Sat, 10 Aug 2019 00:00:00 +0000</pubDate><guid>https://florianwinkelbauer.com/posts/2019-08-10-literate-dotfiles/</guid><description>The Irreal blog has recently published a post about Managing dotfiles with Org. The idea is simple: Put your configuration files and other scripts in a central (version controlled) place and use Emacs to create the &amp;ldquo;real files&amp;rdquo; based on the content of your org file.
Here&amp;rsquo;s a short example:
* Git #+BEGIN_SRC conf :tangle &amp;quot;~/.gitconfig&amp;quot; :padline no [user] email = max@mustermann.com name = Max Mustermann [status] showUntrackedFiles = all [alias] lg = log --color --graph --oneline --decorate --abbrev-commit #+END_SRC #+BEGIN_SRC fundamental :tangle &amp;quot;~/.</description></item><item><title>Diffing Collaborative Text</title><link>https://florianwinkelbauer.com/posts/2019-07-23-text-diff/</link><pubDate>Tue, 23 Jul 2019 00:00:00 +0000</pubDate><guid>https://florianwinkelbauer.com/posts/2019-07-23-text-diff/</guid><description>A common advice I&amp;rsquo;ve read in the past suggests, that we should write text documents (like LaTeX documents or Markdown documentation) in a way, so that each sentence is put on its own line. This gives us an easier time to create diffs of documents which are created in a collaborative fashion.
Emacs offers a function fill-paragraph, which breaks a given line before a specific column width. This might look like this:</description></item><item><title>Digging into Rust</title><link>https://florianwinkelbauer.com/posts/2019-07-21-rust/</link><pubDate>Sun, 21 Jul 2019 00:00:00 +0000</pubDate><guid>https://florianwinkelbauer.com/posts/2019-07-21-rust/</guid><description>I&amp;rsquo;ve recently finished reading the The Rust Programming Language Book while on vacation. While I&amp;rsquo;ve heard that programming in Rust is pretty much a fight with the borrow checker, I haven&amp;rsquo;t had a clear idea what this could really mean. Well, now I know. The borrow checker is friend and foe at the same time. I&amp;rsquo;m still far away from grasping all concepts mentioned in the book, but I was able to produce my very first (useful!</description></item><item><title>Learning New Old Tricks</title><link>https://florianwinkelbauer.com/posts/2019-07-06-new-old/</link><pubDate>Sat, 06 Jul 2019 00:00:00 +0000</pubDate><guid>https://florianwinkelbauer.com/posts/2019-07-06-new-old/</guid><description>Sometimes, you discover something, that others have known for a long time. Last week, I&amp;rsquo;ve discovered how useful a ~/bin directory can be.
Linux After creating a ~/bin directory on my Ubuntu machine, the directory is already part of the PATH variable. Any executable or script put in the ~/bin directory can be turned into a global available command after changing permissions and reloading the profile:
mkdir ~/bin cp /path/to/script ~/bin chmod +x ~/bin/script .</description></item><item><title>Creating a Self-Updating Chocolatey Package</title><link>https://florianwinkelbauer.com/posts/2019-06-19-choco-self-update/</link><pubDate>Wed, 19 Jun 2019 00:00:00 +0000</pubDate><guid>https://florianwinkelbauer.com/posts/2019-06-19-choco-self-update/</guid><description>More and more applications ship with an automatic update mechanisms, which downloads new versions of the application as soon as they are available. A command line option such as myapp.exe --update looks nice, but the update process is tricky, as we cannot simply replace the application while its running.
A very minimalist approach, which can work for command line tools, relies on the Chocolatey package manager. Here&amp;rsquo;s an example:
Package structure:</description></item><item><title>Custom.el Snippets</title><link>https://florianwinkelbauer.com/posts/2019-06-03-customel-snippets/</link><pubDate>Mon, 03 Jun 2019 00:00:00 +0000</pubDate><guid>https://florianwinkelbauer.com/posts/2019-06-03-customel-snippets/</guid><description>My Emacs configuration contains a custom.el file, which should contain custom code that is only relevant on a specific machine. That&amp;rsquo;s why this file is not tracked using git. More and more bits of useful snippets show up in my custom.el file and I&amp;rsquo;d like to jot down some examples which I might expand on in the future.
Calling Command Line Tools This snippet is inspired by a blog post which I&amp;rsquo;ve found on /r/emacs.</description></item><item><title>Emacs and Windows Subsystem for Linux</title><link>https://florianwinkelbauer.com/posts/2019-04-10-emacs-wsl/</link><pubDate>Wed, 10 Apr 2019 00:00:00 +0000</pubDate><guid>https://florianwinkelbauer.com/posts/2019-04-10-emacs-wsl/</guid><description>While setting up Flyspell on Linux was a really straightforward process, I was really struggling with spell checking on Windows. After giving up and trying again several times, I have finally found a solution which is ok-ish using aspell. There&amp;rsquo;s a Windows port for aspell, but the last time I&amp;rsquo;ve checked the latest release was several years old. So instead I&amp;rsquo;m running aspell using WSL. My steps look like this:</description></item><item><title>Threat Level Heatnight</title><link>https://florianwinkelbauer.com/posts/2019-03-27-threat-level-heatnight/</link><pubDate>Wed, 27 Mar 2019 00:00:00 +0000</pubDate><guid>https://florianwinkelbauer.com/posts/2019-03-27-threat-level-heatnight/</guid><description>In the past I&amp;rsquo;ve had a few occasions where I had to create a WiX installer for a C# project. But independent of whatever Google search query I tried, I simply could not figure out how to use heat.exe to auto-generate the content of my .msi files. Luckily, because of this lovely StackOverflow post, this time was different. I&amp;rsquo;ll cite the steps mentioned in this post so that I&amp;rsquo;ll hopefully never forget them:</description></item><item><title>Use PowerShell Scripts in Git Hooks</title><link>https://florianwinkelbauer.com/posts/2019-03-11-powershell-git-hooks/</link><pubDate>Mon, 11 Mar 2019 00:00:00 +0000</pubDate><guid>https://florianwinkelbauer.com/posts/2019-03-11-powershell-git-hooks/</guid><description>Adding a small git hook into a project is rather easy. The following hook calls a PowerShell script which in turn runs a psake task to search for linter issues. The script (./.git/hooks/pre-push) looks like this:
#!/bin/sh C:/Windows/System32/WindowsPowerShell/v1.0/powershell.exe -Command 'psake Invoke-Linter' Warning: Hooks should not contain carriage returns. Use LF instead of CRLF.
And here&amp;rsquo;s a tiny psake task which helps me to install git hooks:
task Install-GitHooks { Get-ChildItem '.</description></item><item><title>Install a Visual Studio Extension using Powershell</title><link>https://florianwinkelbauer.com/posts/2019-03-07-install-vsix-powershell/</link><pubDate>Thu, 07 Mar 2019 00:00:00 +0000</pubDate><guid>https://florianwinkelbauer.com/posts/2019-03-07-install-vsix-powershell/</guid><description>One of my previous posts outlined how to manage Visual Studio extension installations by creating Chocolatey packages for each and every VSIX file you want to install. This works fine in an environment where you are already using an existing Chocolatey repository to hold custom or internalized packages. The following PowerShell snippet presents a way to install VSIX files without relying on Chocolatey:
function Get-VsixFile { param( [Parameter(Mandatory = $true)] [string]$Url ) $page = Invoke-WebRequest -Uri $Url $json = $page.</description></item><item><title>Emacs Org-Mode Links are Fun</title><link>https://florianwinkelbauer.com/posts/2019-01-30-emacs-orglink/</link><pubDate>Wed, 30 Jan 2019 00:00:00 +0000</pubDate><guid>https://florianwinkelbauer.com/posts/2019-01-30-emacs-orglink/</guid><description>I have started to use a few of org-mode&amp;rsquo;s link features to help me stay organized in my job. The top of my &amp;ldquo;main&amp;rdquo; org file now includes these statements:
#+LINK: issue https://company.issue.tracker.com/ticket?id= #+LINK: tree elisp:(neotree-dir &amp;quot;%s&amp;quot;) #+LINK: dir elisp:(setq default-directory &amp;quot;%s&amp;quot;) Now I can write outlines that look something like this:
* [[tree:D:/Projects/SomeProject][Some Project]] ** [[issue:42][Major Bug]] I have taken these steps to narrow the possible causes: - foo - bar - fizz The topmost headline can now give me a tree view of the &amp;ldquo;Some Project&amp;rdquo; directory, while the second headline opens a particular ticket in my default browser.</description></item><item><title>Poor Man's PowerShell Provisioning</title><link>https://florianwinkelbauer.com/posts/2019-01-21-powershell-provision/</link><pubDate>Mon, 21 Jan 2019 00:00:00 +0000</pubDate><guid>https://florianwinkelbauer.com/posts/2019-01-21-powershell-provision/</guid><description>I&amp;rsquo;m a fan of &amp;ldquo;infrastructure as code&amp;rdquo;, which is why I have scripts which help me to setup my own computers. Instead of relying on &amp;ldquo;heavy hitters&amp;rdquo; such as Chef, Ansible or Puppet, my Windows provisioning scripts rely on PowerShell and Chocolatey. I am aware of other tools such as Boxstarter, but I deliberately choose a more manual and bare bones approach in favor of improved error handling.
I have created three PowerShell functions which help me to keep my provisioning scripts simple and well-arranged:</description></item><item><title>My Emacs Journey 2018</title><link>https://florianwinkelbauer.com/posts/2019-01-01-emacs-journey/</link><pubDate>Tue, 01 Jan 2019 00:00:00 +0000</pubDate><guid>https://florianwinkelbauer.com/posts/2019-01-01-emacs-journey/</guid><description>I have started to use Emacs around the summer time after shelving the task of getting started for several weeks. My intention was to find a cross-platform editor which is not Electron-based (e.g. Atom or Visual Studio Code). The thought of learning Emacs, an editor which is pretty much older than I am, seemed intimidating at first, which was the major reason for putting it off for so long. Now, at the start of the new year, I can look back and say, that the invested time was well spent.</description></item><item><title>Copy Files to a Remote Location using Cake</title><link>https://florianwinkelbauer.com/posts/2018-12-23-cake-netuse/</link><pubDate>Sun, 23 Dec 2018 00:00:00 +0000</pubDate><guid>https://florianwinkelbauer.com/posts/2018-12-23-cake-netuse/</guid><description>I have recently had the need to copy files from one Windows machine to another in a Cake build task. A rather easy way to achieve this is to use the net command line tool, which I have wrapped into a few lines of C#. Here&amp;rsquo;s how to use the code:
readonly var target = Argument(&amp;quot;target&amp;quot;, &amp;quot;Default&amp;quot;); Task(&amp;quot;Default&amp;quot;) .Does(() =&amp;gt; { using (var session = NetUse(&amp;quot;\\\\some-machine&amp;quot;, &amp;quot;domain\\user&amp;quot;, &amp;quot;password&amp;quot;)) { // Use Cake's existing IO library CopyFileToDirectory(&amp;quot;myfile.</description></item><item><title>Creating VSIX Chocolatey Packages</title><link>https://florianwinkelbauer.com/posts/2018-11-26-chocolatey-vsix/</link><pubDate>Mon, 26 Nov 2018 00:00:00 +0000</pubDate><guid>https://florianwinkelbauer.com/posts/2018-11-26-chocolatey-vsix/</guid><description>This post outlines how to create a Chocolatey package for a VSIX file based on the Cake for Visual Studio extension.
We will start with the package definition:
&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt; &amp;lt;package xmlns=&amp;quot;http://schemas.microsoft.com/packaging/2015/06/nuspec.xsd&amp;quot;&amp;gt; &amp;lt;metadata&amp;gt; &amp;lt;id&amp;gt;my.vs2017.cake&amp;lt;/id&amp;gt; &amp;lt;title&amp;gt;Visual Studio 2017 Cake Extension&amp;lt;/title&amp;gt; &amp;lt;version&amp;gt;0.2.0.0&amp;lt;/version&amp;gt; &amp;lt;authors&amp;gt;Cake Build&amp;lt;/authors&amp;gt; &amp;lt;owners&amp;gt;Florian Winkelbauer&amp;lt;/owners&amp;gt; &amp;lt;requireLicenseAcceptance&amp;gt;false&amp;lt;/requireLicenseAcceptance&amp;gt; &amp;lt;description&amp;gt;Adds the Cake extension to Visual Studio 2017&amp;lt;/description&amp;gt; &amp;lt;copyright&amp;gt;Copyright 2018&amp;lt;/copyright&amp;gt; &amp;lt;tags&amp;gt;cake visual studio 2017&amp;lt;/tags&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency id=&amp;quot;chocolatey-visualstudio.extension&amp;quot; /&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;/metadata&amp;gt; &amp;lt;/package&amp;gt; Notice the declared dependency chocolatey-visualstudio.</description></item></channel></rss>