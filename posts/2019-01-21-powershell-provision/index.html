<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Poor Man's PowerShell Provisioning</title>
<meta name="generator" content="Org Mode" />
<meta name="author" content="Florian Winkelbauer">
<link rel="stylesheet" href="/site.css" type="text/css">
</head>
<body>
<div id="preamble" class="status">
<nav>
<a href="/">Home</a>
<a href="/notes">Notes</a>
<a href="/posts">Posts</a>
<a href="/projects">Projects</a>
</nav>
</div>
<div id="content" class="content">
<header>
<h1 class="title">Poor Man's PowerShell Provisioning</h1>
</header><p>
I'm a fan of "infrastructure as code", which is why I have scripts which help me
to setup my own computers. Instead of relying on "heavy hitters" such as Chef,
Ansible or Puppet, my Windows provisioning scripts rely on PowerShell and
Chocolatey. I am aware of other tools such as Boxstarter, but I deliberately
choose a more manual and bare bones approach in favor of improved error
handling.
</p>

<p>
I have created three PowerShell functions which help me to keep my provisioning
scripts simple and well-arranged:
</p>

<div id="outline-container-org962c3df" class="outline-2">
<h2 id="org962c3df">Step</h2>
<div class="outline-text-2" id="text-org962c3df">
<p>
Several PowerShell instructions can be grouped together as a step:
</p>

<div class="org-src-container">
<pre class="src src-powershell">function step {
    param(
        [Parameter(Mandatory = $true)]
        [string]$Name,
        [Parameter(Mandatory = $true)]
        [scriptblock]$Do,
        [scriptblock]$If = { $true }
    )

    if (&amp; $If) {
        Write-Output '============================================================'
        Write-Output "Starting step '$Name'"
        Write-Output '------------------------------------------------------------'

        $startTime = Get-Date

        &amp; $Do

        $endTime = Get-Date
        $duration = $endTime - $startTime

        Write-Output '------------------------------------------------------------'
        Write-Output "Finished step '$Name' ($duration)"
        Write-Output '============================================================'
    }
    else {
        Write-Output '============================================================'
        Write-Output "Skipping step '$Name'"
        Write-Output '============================================================'
    }
}
</pre>
</div>

<p>
Which might look like this:
</p>

<div class="org-src-container">
<pre class="src src-powershell">step 'Configure Windows explorer' {
    $explorerKey = 'HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced'
    # Show file extensions in explorer
    Set-ItemProperty -Path $explorerKey -Name HideFileExt -Value 0
    # Opens explorer at 'This PC' instead of 'Quick Access'
    Set-ItemProperty -Path $explorerKey -Name LaunchTo -Value 1
}
</pre>
</div>

<p>
Or like this:
</p>

<div class="org-src-container">
<pre class="src src-powershell">$configFile = 'C:\meaning.ini'

step 'Write important config file' -If {
    -not (Test-Path $configFile)
} -Do {
    Set-Content -Value 'answer = 42' -Path $configFile
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org1b10791" class="outline-2">
<h2 id="org1b10791">Once</h2>
<div class="outline-text-2" id="text-org1b10791">
<p>
Sometimes I'd like to run a block of code once, but I don't have any decent way
of checking if the block was already executed. The <code>once</code> function is a
specialized step, which uses a "checkpoint file" to give a step the "executed
just once" property:
</p>

<div class="org-src-container">
<pre class="src src-powershell">function once {
    param(
        [Parameter(Mandatory = $true)]
        [string]$Name,
        [Parameter(Mandatory = $true)]
        [scriptblock]$ScriptBlock,
        [System.IO.DirectoryInfo]$CheckpointDirectory = (Join-Path $env:ProgramData 'my.provision')
    )

    $checkpointFileName = $Name + '.checkpoint'

    foreach ($invalidFileNameChar in [System.IO.Path]::GetInvalidFileNameChars()) {
        $checkpointFileName = $checkpointFileName.Replace($invalidFileNameChar, '_')
    }

    $checkpointFile = Join-Path $CheckpointDirectory $checkpointFileName

    step $Name -If {
        -not (Test-Path $checkpointFile)
    } -Do {
        &amp; $ScriptBlock

        New-Item -Path $checkpointFile -Force | Out-Null
    }
}
</pre>
</div>

<p>
Here's an example:
</p>

<div class="org-src-container">
<pre class="src src-powershell">once 'Write important config file' {
    Set-Content -Value 'answer = 42' -Path 'C:\meaning.ini'
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf5bc0c3" class="outline-2">
<h2 id="orgf5bc0c3">Manual</h2>
<div class="outline-text-2" id="text-orgf5bc0c3">
<p>
If all automation attempts fail, I use <code>manual</code> as a fallback:
</p>

<div class="org-src-container">
<pre class="src src-powershell">function manual {
    param(
        [Parameter(Mandatory = $true)]
        [string]$Name,
        [Parameter(Mandatory = $true)]
        [scriptblock]$ScriptBlock,
        [bool]$If = $true
    )

    step -Name $Name -If $If -Do {
        $nonInteractive = [bool]([Environment]::GetCommandLineArgs() -like '-noni*')

        if ($nonInteractive) {
            throw 'Cannot perform manual step in non-interactive PowerShell session'
        }

        &amp; $ScriptBlock

        Write-Output ''
        Read-Host 'Press ENTER to continue'
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org544d328" class="outline-2">
<h2 id="org544d328">Exec</h2>
<div class="outline-text-2" id="text-org544d328">
<p>
<code>exec</code> makes sure that I can monitor the exit code of a command line tool:
</p>

<div class="org-src-container">
<pre class="src src-powershell">function exec {
    param(
        [Parameter(Mandatory = $true)]
        [scriptblock]$ScriptBlock,
        [int[]]$ValidExitCodes = @(0)
    )

    $global:LASTEXITCODE = 0

    &amp; $ScriptBlock

    if (-not ($global:LASTEXITCODE -in $ValidExitCodes)) {
        throw "Invalid exit code: $($global:LASTEXITCODE)"
    }
}
</pre>
</div>

<p>
Now I can call command line tools like this:
</p>

<div class="org-src-container">
<pre class="src src-powershell">exec { 7z }
exec { git status }
exec -ValidExitCodes 0, 1, 2 { $global:LASTEXITCODE = 2 }
</pre>
</div>

<p>
I can even create a wrapper function to deal with restarts if a Chocolatey
package installation returns the exit code <code>3010</code>:
</p>

<div class="org-src-container">
<pre class="src src-powershell">function choco-exec {
    param(
        [Parameter(Mandatory = $true)]
        [scriptblock]$ScriptBlock,
        [switch]$ConfirmBeforeReboot
    )

    exec -ScriptBlock $ScriptBlock -ValidExitCodes @(0, 1641, 3010)

    if ($global:LASTEXITCODE -eq 3010) {
        Write-Warning "Chocolatey indicates, that a restart is necessary"
        Restart-Computer -Confirm:$ConfirmBeforeReboot
    }
}
</pre>
</div>

<p>
Which I can call like this:
</p>

<div class="org-src-container">
<pre class="src src-powershell">choco-exec { choco install git -y }
choco-exec { choco install dotnet4.7.2 -y } -ConfirmBeforeReboot
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Published: 2019-01-21</p>
<footer>
<p>Copyright 2024, Florian Winkelbauer. All rights reserved.</p>
</footer>
</div>
</body>
</html>