<!doctype html><html lang=en><head><title>Poor Man's PowerShell Provisioning</title><meta charset=utf-8><meta name=author content="Florian Winkelbauer"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=canonical href=https://florianwinkelbauer.com/posts/2019-01-21-powershell-provision/><link rel=alternate type=application/rss+xml title=RSS href=https://florianwinkelbauer.com/index.xml><link rel=stylesheet href=https://florianwinkelbauer.com/main.css></head><body><header class=dark><h2><a href=https://florianwinkelbauer.com/>Florian Winkelbauer</a></h2><nav><a href=/about>About</a>
<a href=/notes>Notes</a>
<a href=/projects>Projects</a></nav></header><main><article><header><h1><a href=https://florianwinkelbauer.com/posts/2019-01-21-powershell-provision/>Poor Man's PowerShell Provisioning</a></h1><time datetime=2019-01-21T00:00:00Z>January 21, 2019</time></header><p>I&rsquo;m a fan of &ldquo;infrastructure as code&rdquo;, which is why I have scripts which help me
to setup my own computers. Instead of relying on &ldquo;heavy hitters&rdquo; such as Chef,
Ansible or Puppet, my Windows provisioning scripts rely on PowerShell and
Chocolatey. I am aware of other tools such as Boxstarter, but I deliberately
choose a more manual and bare bones approach in favor of improved error
handling.</p><p>I have created three PowerShell functions which help me to keep my provisioning
scripts simple and well-arranged:</p><h2 id=step>Step</h2><p>Several PowerShell instructions can be grouped together as a step:</p><pre><code class=language-powershell>function step {
    param(
        [Parameter(Mandatory = $true)]
        [string]$Name,
        [Parameter(Mandatory = $true)]
        [scriptblock]$Do,
        [scriptblock]$If = { $true }
    )

    if (&amp; $If) {
        Write-Output '============================================================'
        Write-Output &quot;Starting step '$Name'&quot;
        Write-Output '------------------------------------------------------------'

        $startTime = Get-Date

        &amp; $Do

        $endTime = Get-Date
        $duration = $endTime - $startTime

        Write-Output '------------------------------------------------------------'
        Write-Output &quot;Finished step '$Name' ($duration)&quot;
        Write-Output '============================================================'
    }
    else {
        Write-Output '============================================================'
        Write-Output &quot;Skipping step '$Name'&quot;
        Write-Output '============================================================'
    }
}
</code></pre><p>Which might look like this:</p><pre><code class=language-powershell>step 'Configure Windows explorer' {
    $explorerKey = 'HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced'
    # Show file extensions in explorer
    Set-ItemProperty -Path $explorerKey -Name HideFileExt -Value 0
    # Opens explorer at 'This PC' instead of 'Quick Access'
    Set-ItemProperty -Path $explorerKey -Name LaunchTo -Value 1
}
</code></pre><p>Or like this:</p><pre><code class=language-powershell>$configFile = 'C:\meaning.ini'

step 'Write important config file' -If {
    -not (Test-Path $configFile)
} -Do {
    Set-Content -Value 'answer = 42' -Path $configFile
}
</code></pre><h2 id=once>Once</h2><p>Sometimes I&rsquo;d like to run a block of code once, but I don&rsquo;t have any decent way
of checking if the block was already executed. The <code>once</code> function is a
specialized step, which uses a &ldquo;checkpoint file&rdquo; to give a step the &ldquo;executed
just once&rdquo; property:</p><pre><code class=language-powershell>function once {
    param(
        [Parameter(Mandatory = $true)]
        [string]$Name,
        [Parameter(Mandatory = $true)]
        [scriptblock]$ScriptBlock,
        [System.IO.DirectoryInfo]$CheckpointDirectory = (Join-Path $env:ProgramData 'my.provision')
    )

    $checkpointFileName = $Name + '.checkpoint'

    foreach ($invalidFileNameChar in [System.IO.Path]::GetInvalidFileNameChars()) {
        $checkpointFileName = $checkpointFileName.Replace($invalidFileNameChar, '_')
    }

    $checkpointFile = Join-Path $CheckpointDirectory $checkpointFileName

    step $Name -If {
        -not (Test-Path $checkpointFile)
    } -Do {
        &amp; $ScriptBlock

        New-Item -Path $checkpointFile -Force | Out-Null
    }
}
</code></pre><p>Here&rsquo;s an example:</p><pre><code class=language-powershell>once 'Write important config file' {
    Set-Content -Value 'answer = 42' -Path 'C:\meaning.ini'
}
</code></pre><h2 id=manual>Manual</h2><p>If all automation attempts fail, I use <code>manual</code> as a fallback:</p><pre><code class=language-powershell>function manual {
    param(
        [Parameter(Mandatory = $true)]
        [string]$Name,
        [Parameter(Mandatory = $true)]
        [scriptblock]$ScriptBlock,
        [bool]$If = $true
    )

    step -Name $Name -If $If -Do {
        $nonInteractive = [bool]([Environment]::GetCommandLineArgs() -like '-noni*')

        if ($nonInteractive) {
            throw 'Cannot perform manual step in non-interactive PowerShell session'
        }

        &amp; $ScriptBlock

        Write-Output ''
        Read-Host 'Press ENTER to continue'
    }
}
</code></pre><h2 id=exec>Exec</h2><p><code>exec</code> makes sure that I can monitor the exit code of a command line tool:</p><pre><code class=language-powershell>function exec {
    param(
        [Parameter(Mandatory = $true)]
        [scriptblock]$ScriptBlock,
        [int[]]$ValidExitCodes = @(0)
    )

    $global:LASTEXITCODE = 0

    &amp; $ScriptBlock

    if (-not ($global:LASTEXITCODE -in $ValidExitCodes)) {
        throw &quot;Invalid exit code: $($global:LASTEXITCODE)&quot;
    }
}
</code></pre><p>Now I can call command line tools like this:</p><pre><code class=language-powershell>exec { 7z }
exec { git status }
exec -ValidExitCodes 0, 1, 2 { $global:LASTEXITCODE = 2 }
</code></pre><p>I can even create a wrapper function to deal with restarts if a Chocolatey
package installation returns the exit code <code>3010</code>:</p><pre><code class=language-powershell>function choco-exec {
    param(
        [Parameter(Mandatory = $true)]
        [scriptblock]$ScriptBlock,
        [switch]$ConfirmBeforeReboot
    )

    exec -ScriptBlock $ScriptBlock -ValidExitCodes @(0, 1641, 3010)

    if ($global:LASTEXITCODE -eq 3010) {
        Write-Warning &quot;Chocolatey indicates, that a restart is necessary&quot;
        Restart-Computer -Confirm:$ConfirmBeforeReboot
    }
}
</code></pre><p>Which I can call like this:</p><pre><code class=language-powershell>choco-exec { choco install git -y }
choco-exec { choco install dotnet4.7.2 -y } -ConfirmBeforeReboot
</code></pre></article></main><footer><p>Copyright 2023, Florian Winkelbauer. All rights reserved.</p></footer></body></html>