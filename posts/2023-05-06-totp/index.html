<!doctype html><html lang=en><head><title>Implementing TOTP</title><meta charset=utf-8><meta name=generator content="Hugo 0.111.3"><meta name=author content="Florian Winkelbauer"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=canonical href=https://florianwinkelbauer.com/posts/2023-05-06-totp/><link rel=alternate type=application/rss+xml title=RSS href=https://florianwinkelbauer.com/index.xml><link rel=stylesheet href=https://florianwinkelbauer.com/main.css></head><body><header class=dark><h2><a href=https://florianwinkelbauer.com/>Florian Winkelbauer</a></h2><nav><a href=/about>About</a>
<a href=/notes>Notes</a>
<a href=/projects>Projects</a></nav></header><main><article><header><h1><a href=https://florianwinkelbauer.com/posts/2023-05-06-totp/>Implementing TOTP</a></h1><time datetime=2023-05-06T00:00:00Z>May 06, 2023</time></header><p>Here&rsquo;s another short post with a code snippet. I have recently stumbled over a
post by Drew DeVault about <a href=https://drewdevault.com/2022/10/18/TOTP-is-easy.html>implementing TOTP</a> and I was wondering
how his Python example would turn out in C#. Other people have already done a
much better job at this (have a look at the Otp.NET library), but why not give
it a shot anyway.</p><p>Example usage:</p><pre><code class=language-c#>var totp = TOTP.Compute(&quot;3N2OTFHXKLR2E3WNZSYQ====&quot;);
</code></pre><p>And the implementation:</p><pre><code class=language-c#>// TOTP.cs is based on:
// - https://github.com/kspearrin/Otp.NET
// - https://github.com/susam/mintotp
// - https://drewdevault.com/2022/10/18/TOTP-is-easy.html
//
// Base32.cs is copied from:
// - https://github.com/dotnet/aspnetcore/blob/01cc669960821e23ef3275cd5ad81f7192972010/src/Identity/Extensions.Core/src/Base32.cs
public static class TOTP
{
    private const int DigitsCount = 6;
    private const long WindowSeconds = 30L;
    private const long UnixEpocTicks = 621355968000000000L;
    private const long TicksToSeconds = 10000000L;

    public static string Compute(string secret)
    {
        return Compute(secret, ToCounter(DateTime.UtcNow));
    }

    private static string Compute(string secret, long counter)
    {
        var key = ToKey(secret);
        var bytes = ToBigEndianBytes(counter);
        var hash = HMACSHA1.HashData(key, bytes);
        var offset = hash[^1] &amp; 0x0f;

        var otp = (hash[offset] &amp; 0x7f) &lt;&lt; 24
            | (hash[offset + 1] &amp; 0xff) &lt;&lt; 16
            | (hash[offset + 2] &amp; 0xff) &lt;&lt; 8
            | (hash[offset + 3] &amp; 0xff) % 1000000;

        return ToStringCode(otp);
    }

    private static byte[] ToKey(string secret)
    {
        return Base32.FromBase32(
            secret.ToUpper().PadRight(32, '='));
    }

    private static byte[] ToBigEndianBytes(long value)
    {
        var bytes = BitConverter.GetBytes(value);

        Array.Reverse(bytes);

        return bytes;
    }

    private static string ToStringCode(int value)
    {
        var truncated = value % (int)Math.Pow(10, DigitsCount);

        return truncated.ToString().PadLeft(DigitsCount, '0');
    }

    private static long ToCounter(DateTime timeStamp)
    {
        var unixTimeStamp = (timeStamp.Ticks - UnixEpocTicks) / TicksToSeconds;

        return unixTimeStamp / WindowSeconds;
    }
}
</code></pre></article></main><footer><p>Copyright 2023, Florian Winkelbauer. All rights reserved.</p></footer></body></html>